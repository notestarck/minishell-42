 - Afficher un prompt en l’attente d’une nouvelle commande.

 - Posséder un historique fonctionnel.

-Chercher et lancer le bon exécutable (en se basant sur la variable d’environnement
PATH, ou sur un chemin relatif ou absolu)

-Ne pas utiliser plus d’une variable globale. Réfléchissez-y car vous devrez jus-
tifier son utilisation

Ne pas interpréter de quotes (guillemets) non fermés ou de caractères spéciaux non
demandés dans le sujet, tels que \ (le backslash) ou ; (le point-virgule).

Gérer ’ (single quote) qui doit empêcher le shell d’interpréter les méta-caractères
présents dans la séquence entre guillemets.

Gérer " (double quote) qui doit empêcher le shell d’interpréter les méta-caractères
présents dans la séquence entre guillemets sauf le $ (signe dollar).

Implémenter les redirections :
◦< doit rediriger l’entrée.
◦> doit rediriger la sortie.
◦<< doit recevoir un délimiteur et lire l’input donné jusqu’à rencontrer une ligne
contenant le délimiteur. Cependant, l’historique n’a pas à être mis à jour !
◦>> doit rediriger la sortie en mode append.

Implémenter les pipes (caractère |). La sortie de chaque commande de la pipeline
est connectée à l’entrée de la commande suivante grâce à un pipe.

Gérer les variables d’environnement (un $ suivi d’une séquence de caractères)
qui doivent être substituées par leur contenu.
il faut aussi gerer {} pour que les variables puissent s'afficher correctement.

Gérer $? qui doit être substitué par le statut de sortie de la dernière pipeline
exécutée au premier plan.

Gérer ctrl-C, ctrl-D et ctrl-\ qui doivent fonctionner comme dans bash

En mode interactif :
◦ctrl-C affiche un nouveau prompt sur une nouvelle ligne.
◦ctrl-D quitte le shell.
◦ctrl-\ ne fait rien.

Votre shell doit implémenter les builtins suivantes :
◦echo et l’option -n
◦cd uniquement avec un chemin relatif ou absolu
◦pwd sans aucune option
◦export sans aucune option
◦unset sans aucune option
◦env sans aucune option ni argument
◦exit sans aucune option

&& et || avec des parenthèses pour les priorités.
&& cmd1 est exécutée et si son code de retour est égal à 0, alors cmd2 est également exécutée.
|| cmd1 est exécutée et si son code de retour est différent de 0, alors cmd2 est également exécutée.
http://aral.iut-rodez.fr/fr/sanchis/enseignement/bash/ch07s07.html

Les wildcards * doivent fonctionner pour le répertoire courant.







TRucs a faire:
echo avec les redirections + " ne marchent pas
heredoc avec le EOF colle a la redirection
◦ctrl-C affiche un nouveau prompt sur une nouvelle ligne.
◦ctrl-D quitte le shell.
◦ctrl-\ ne fait rien.

A FAIRE - Mettez plusieurs répertoires à PATH (directory1:directory2) et vérifiez
qu'ils sont bien évalués de gauche à droite.

A FAIRE (echo TEST >> t >> t. t dois contenir 2 fois TEST) - Vérifiez si plusieurs instances de la même redirection échouent.

A FAIRE - Entrez une commande, puis ctrl-C, et appuyez sur "Entrée".
Le buffer devrait être vide et il ne devrait plus rien avoir à
exécuter.
◦supprimer les espaces sur les chemins absolu
- un espace + pipe + espace cause segfault
- ctrl-C dans un prompt vide devrait afficher une nouvelle ligne avec un
nouveau prompt.
- ctrl-\ dans un prompt vide ne devrait rien faire.
- ctrl-D dans un prompt vide devrait quitter minishell. Ensuite,
relancez-le.
- ctrl-C dans un prompt après avoir écrit des choses devrait afficher une
nouvelle ligne avec un nouveau prompt.
- Également, le buffer devrait être vide. Appuyez sur "Entrée" afin de vous
assurer que la ligne précédente a été exécutée.
- ctrl-D dans un prompt après avoir écrit des choses ne devrait rien faire.
- ctrl-\ dans un prompt après avoir écrit des choses ne devrait rien faire.
- Essayez ctrl-C après avoir lancé une commande bloquante, comme cat ou grep
sans argument.
- Essayez ctrl-\ après avoir lancé une commande bloquante, comme cat ou grep
sans argument.
- Essayez ctrl-D après avoir lancé une commande bloquante, comme cat ou grep
sans argument.
-free a check
-couper la fonction echo pour la norme